# FuncMark：函数调用式标记语言

## 项目背景

当前在笔记、非论文文档编写常用工具如下：

- word
	- 优点：零门槛使用，不需要会任何语法
	- 缺陷：快捷键存在记忆门槛，初学者必须依赖鼠标，导致编辑效率降低
- markdown工具（如typora）：
	- 优点：简洁轻量，基本功能上手门槛低
	- 缺陷：高级功能的记忆门槛高，对初学者不够友好

为了解决这些局限性，本项目探索性地提出一种函数调用式的标记语言FuncMark，借助代码式补全的优势，提升笔记或随笔的编写体验。

## 项目预期

- 能够支持FuncMark语言的编辑
- 能够实时渲染已经编写好的块
- 能够支持语法补全

## FuncMark语法

通过`@function(parameters)`的函数调用形式实现一个块的渲染

流程：输入@后补全开始运作，当按下回车键选定对应函数时，弹出如下格式供用户编辑：

```
@function(
	param1="",
	param2=""
)
```

当光标移出@到)之间时，进行渲染。

为了降低用户压力，参数不宜过多。对于特殊格式的渲染（如表格），可以选择直接渲染表格，让用户在表格中编辑而非参数式编辑。

**函数表（初期测试）**

| 函数名      | 参数                        | 描述       | 示例                                                        |
| ----------- | --------------------------- | ---------- | ----------------------------------------------------------- |
| `head`      | `text`, `rank`              | 创建标题   | `@head(text="标题", rank=1)`                                |
| `code`      | `text`, `language`, `title` | 创建代码块 | `@code(text="console.log('hello')", language="javascript")` |
| `paragraph` | `text`                      | 创建段落   | `@paragraph(text="这是一个段落")`                           |
| `list`      | `items`, `type`             | 创建列表   | `@list(items="项目1|项目2|项目3", type="ordered")`          |

## 思考：个人笔记用户的需求是什么？

对个人笔记用户而言，现有工具最大的问题在于：

- 没有自动化的历史记录（版本控制），必须手动记录，否则会丢失自己的思维痕迹。
- 许多工具的编辑体验并不流畅，只有极少数像typora这样的标杆才能实现“便签级”编辑体验。

FuncMark并非要取代现有语言，而是为解决用户需求而生。接下来将会讲述FuncMark的优势和局限，并谈谈它为什么是个人笔记理想工具的起点。

## 优势与局限

**优势：**

- 对用户：

	- 语法统一且语义明确，减少编辑的隐式思维负担。核心理念：“所见即所想”。

	- 支持代码补全，用户无需过度记忆语法和参数。

- 对开发者（或技术用户）：

	- 实现极为简单，解析难度低，模块化程度高，让开发者能够将大量开发精力放在用户体验上，而非繁琐的语法处理
	- 可拓展性极强，支持技术用户自定义插件，实现个性化工具。

**局限：**

- 为了保证高语义性，FuncMark文件的存储长度比同内容markdown更长。
	- 评估：对个人用户来说几乎无影响，长文本的存储瓶颈也不会是语法。影响较弱。
- 生态不如markdown完善。
	- 评估：无需替代markdown生态，FuncMark的易解析性可以轻松兼容.fm到.md的转换，便于用户迁移文件。影响较弱。

- 代码式编辑对非技术用户可能不友好。
	- 评估：函数补全（补全函数名+参数）可以大幅缓解，但是需要实际调研和改进。影响中等。

综上，即使FuncMark并非完美的语言，但是其设计理念扎根于用户体验，为理想的个人笔记项目提供了合理的起点。

## 未来计划

- 完成基本的FuncMark语法和解析器，支持基本编辑
- 开发轻量级编辑器，专注于用户体验
- 添加自动化版本控制，实现真正的“思维记录”
